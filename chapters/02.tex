
\chapter{Requirements and tools}
\label{chap:requirements-and-tools}

The project requirements outline the system's expected functions and performance, detailing the features and capabilities that meet user needs. This forms the foundation for designing and implementing the system's core functionalities.

\section{Functional Requirements}

Functional requirements define the specific behavior and functions of the system. For the dice game application, these include:

\begin{enumerate}
    \item {\bfseries Basic Functions}: The system must implement fundamental dice game mechanics, including:
    \begin{itemize}
        \item Ability to play classic dice games
        \item Rolling dice with randomized results
        \item Holding selected dice between rolls
        \item Banking scores based on game rules
        \item Displaying current turn results and game progress
    \end{itemize}
    \item {\bfseries AI Opponent}: The system should feature an AI opponent that dynamically adapts to player behavior and skill level.
    \item {\bfseries Game Variants}: The application should support a variety of dice games, providing diverse gameplay options.
    \item {\bfseries Player Analytics}: The system should track and analyze player statistics to inform AI decision-making.
    \item {\bfseries User Interface}: The application should provide an intuitive and consistent user interface for all game variants.
    \item {\bfseries Real-Time Feedback}: Users should receive performance feedback to understand and improve their gameplay strategies.
    \item {\bfseries Image Recognition}: The system should accurately detect and recognize physical dice through the device camera, detecting dice faces in real-time and accurately recognizing pip values.
\end{enumerate}

\section{Non-functional Requirements}
Non-functional requirements are essential for ensuring the quality and performance of the system. They help address issues such as latency, scalability, usability, reliability, and security. For the application, the following non-functional requirements are identified:
\begin{enumerate}
\item {\bfseries Performance}: The application should deliver a smooth user experience on mobile devices, with minimal latency in AI decision-making.
\item {\bfseries Scalability}: The system should be able to handle an increasing number of users and game variants.
\item {\bfseries Usability}: The user interface should be easy to navigate and accessible to diverse users.
\item {\bfseries Reliability}: The application should consistently provide accurate AI behavior and player analytics, maintaining user satisfaction.
\end{enumerate}

\section{Use Case Modelling}
Use cases describe how users interact with the system, illustrated using UML diagrams that visualize user interactions and the application's features.

\subsubsection{Main Menu Use Case}
Upon launching the application, users encounter the main menu, which serves as the central hub for interaction. This interface provides access to various game modes, settings, player statistics, and instructional materials, as shown in Figure~\ref{fig:main_menu_usecase}.

\begin{figure}[ht!]
    \centering
    \includesvg[scale=0.9]{uml/render/main_menu_usecase.svg}
    \caption{Use case diagram for the game's main menu.}
    \label{fig:main_menu_usecase}
\end{figure}

Users can start a new game by selecting either the classic or custom game mode, allowing them to engage with predefined rules or configure their own gameplay mechanics. The statistics menu provides insights into player performance, including past game results and analysis. The settings menu enables players to configure parameters such as difficulty level, audio preferences, and visual themes. Additionally, the game rules and instructions section offers a reference for understanding mechanics and strategies. The application also integrates virtual dice recognition, enabling users to interact with real-world dice using image recognition. Table~\ref{tab:main_menu_usecase} summarizes the key interactions available in the main menu.

\begin{table}[ht!]
    \centering
    \begin{tabular}{|l|p{12cm}|}
        \hline
        \textbf{Actor} & \textbf{Description} \\
        \hline
               & \textbf{Start Game}: Initiates gameplay by selecting either classic or custom game modes. \\
               & \textbf{Show Settings}: Provides access to customization options, including difficulty levels and interface preferences. \\
        Player & \textbf{Show Instructions}: Displays an overview of game mechanics and rules. \\
               & \textbf{Show Statistics}: Enables users to track their performance and game history. \\
               & \textbf{View Player Analysis}: Provides in-depth statistics on past games, allowing players to analyze trends and optimize strategies. \\
        \hline
    \end{tabular}    
    \caption{Main Menu Use Case Interactions}
    \label{tab:main_menu_usecase}
\end{table}

\subsubsection{Game Use Case}
The game system encapsulates core gameplay mechanics, allowing players to engage in dice-based games in both physical and digital formats. Players roll dice, make strategic decisions, and compete against AI opponents that use heuristic probability to optimize their moves, as shown in Figure~\ref{fig:game_usecase}.

\begin{figure}[ht!]
    \centering
    \includesvg[scale=0.7]{uml/render/game_usecase.svg}
    \caption{Use case diagram for the game's core gameplay.}
    \label{fig:game_usecase}
\end{figure}

\begin{table}[ht!]
    \centering
    \begin{tabular}{|l|p{12cm}|}
        \hline
        \textbf{Actor} & \textbf{Description} \\
        \hline
               & \textbf{Play Classic Game}: Engage in traditional dice games with predefined rules. \\
               & \textbf{Play Custom Game}: Define custom rules and gameplay parameters. \\
               & \textbf{Roll Dice}: Roll dice manually or use virtual dice detection. \\
               & \textbf{Hold Dice}: Select specific dice to keep for strategic advantage. \\
        Player & \textbf{Bank Score}: Secure points to prevent potential losses. \\
               & \textbf{Earn Achievements}: Unlock rewards for reaching milestones. \\
               & \textbf{Use Virtual Mode}: Detect and capture dice roll results using image recognition. \\
               & \textbf{Detect Dice Values}: Process dice images to identify pips and determine values. \\
        \hline
        AI & \textbf{Make Strategic Decisions}: Use heuristic probability to evaluate the game state and optimize moves. \\
        \hline
    \end{tabular}    
    \caption{Game Use Case Interactions}
    \label{tab:game_usecase}
\end{table}

Players can roll dice using the virtual interface or capture real dice rolls via image recognition, enabling seamless integration between physical and digital gameplay. During a turn, players can choose to hold specific dice to refine their strategy or bank points to secure their score. AI opponents analyze game conditions using heuristic probability to make strategic decisions, adding challenge and unpredictability to the gameplay. Table~\ref{tab:game_usecase} outlines the primary interactions within the game system.

\section{Description of Tools and Technologies}

\subsection{Technologies and Tools}

\subsubsection{Kotlin}
\label{sec:kotlin}
Kotlin is a modern programming language that offers features like null safety, extension functions, and interoperability with Java, making it a preferred choice for Android development. Kotlin was chosen for this project to write the entire application code because of these advantages: its concise syntax reduces boilerplate and enhances readability, while its features like null safety improve application stability by reducing the risk of null pointer exceptions. Furthermore, its seamless integration with the Java ecosystem ensures that it can readily use Java libraries and existing Android code, and the language's ability to be compiled down to bytecode means increased cross-platform support. These advantages together result in enhanced productivity and maintainability~\cite{bib:kotlin}.

\subsubsection{Roboflow}
\label{sec:roboflow}
Roboflow is a computer vision platform that offers tools for dataset management, model training, and deployment \cite{bib:roboflow}. Roboflow was selected for this project because it significantly simplifies the process of building and deploying a custom dice detection model. The platform's efficient dataset preparation and augmentation capabilities helped improve the robustness of the model despite not having a large custom dataset \cite{bib:kavidataset}. Moreover, its tools for model training and optimization allowed for the efficient creation of a model suitable for mobile deployment. Importantly, Roboflow's managed API provides a seamless way to integrate the trained model into the Android application, enabling real-time inference capabilities that are crucial for the interactive dice-recognition component of the application, thereby enhancing the application's performance and reliability.

\subsubsection{Figma}
\label{sec:figma}
Figma is a collaborative interface design tool that was used to create the application's initial designs and prototypes~\cite{bib:figma}. Figma was used due to its collaborative nature allowing different stakeholders to collaborate during the design process and provide fast feedback. The tool provided a good level of functionality, and was used to create the user interface that could be implemented in the project, saving time during the development process, reducing effort.

\subsubsection{Git}
\label{sec:git}
Git is a distributed version control system that allows developers to track changes in their code-base through GitHub, collaborate with others, and manage project history efficiently. Git, hosted by GitHub, was chosen for source code management in this project because it enables collaborative development, allowing multiple developers to work on the project simultaneously without encountering conflicts. Additionally, Git's ability to track code versions is essential for maintaining the project's history, enabling developers to revert to previous states and maintain overall code integrity efficiently~\cite{bib:git}.

\subsubsection{Android Studio}
\label{sec:androidstudio}
Android Studio is the official integrated development environment for Android development, providing tools for building, testing, and debugging Android applications. Android Studio was used because it provides a comprehensive toolset that enables an efficient workflow. Its features, including a code editor, debugging tools, and emulator support, are essential for developing Android applications quickly and effectively. The deep integration with the Android platform helps in ensuring the application works well on the intended target platform~\cite{bib:androidstudio}.

\subsubsection{Jetpack Compose}
\label{sec:jetpackcompose}
Jetpack Compose is a modern toolkit for building native Android UI, offering a declarative approach that simplifies UI development and enhances code readability. It provides modular re-composition, allowing UI elements to update independently, which optimizes UI rendering efficiency. Although comparisons suggest that XML-based layouts may achieve better rendering speeds in certain scenarios, Jetpack Compose was chosen for its advantages in terms of flexibility, maintainability, and modern approach to Android UI development~\cite{bib:diva}. Jetpack compose also allows for fast and iterative development, which is beneficial for this project~\cite{bib:jetpackcompose}.

\subsection{Libraries}

\subsubsection{Dagger-Hilt}
\label{sec:daggerhilt}
Dagger-Hilt is a dependency injection library for Android that simplifies the setup and management of dependencies in Android applications. Dagger-Hilt was used in this project because it greatly reduces boilerplate code related to dependency injection, improving code modularity and making the project more testable. This is especially important for larger projects, allowing for more structured and organized code. It allows the application to easily scale, and can help with long-term maintainability~\cite{bib:daggerhilt}.

\subsubsection{Lottie Animation}
\label{sec:lottie}
Lottie is a library for rendering animations in real-time, allowing developers to use animations created in Adobe After Effects in their applications. Lottie was selected for its capabilities in rendering vector-based animations smoothly and efficiently, enhancing the application’s user interface. Lottie allowed animations to be created by UI/UX designers using their own tools and then be added into the application without requiring the implementation to be done by programmers. This allows for smoother animations and reduces the technical complexity and improves the user experience~\cite{bib:lottie}.

\subsubsection{Vico Charts}
\label{sec:vicocharts}
Vico Charts is a library for creating interactive and customizable charts in Android applications, providing a variety of chart types and features. Vico Charts was chosen because it offers a wide range of chart types and features that make it easy to represent data visually and dynamically. Vico Charts allows users to more easily interpret their data, and the library’s extensive customization options enable the data to be displayed attractively and consistently with the user interface~\cite{bib:vicocharts}.

\subsubsection{Timber}
\label{sec:timber}
Timber is a logging library for Android that provides a simple and flexible API for logging messages, making it easier to manage log output in Android applications. Timber was used for logging in this project to simplify and standardize the process of logging events and debugging information. Timber removes the clutter that comes from logging, and offers an elegant and easily readable interface and functionality for developers, thereby aiding in debugging and monitoring the application’s behavior~\cite{bib:timber}.

\subsubsection{JUnit 5}
\label{sec:junit}
JUnit 5 is composed of several modules, including JUnit Jupiter which is a combination of the programming and extension model for writing tests and extensions in JUnit 5~\cite{bib:junit}. JUnit 5 was chosen as the testing framework because of its modern architecture which allows for cleaner and more maintainable tests. It provides advanced testing functionalities and allows for an ease of development, allowing for the implementation of unit and integration tests with ease.

