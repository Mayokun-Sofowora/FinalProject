
\chapter{Requirements and tools}
\label{chap:requirements-and-tools}

The project requirements outline the system's expected functions and performance, detailing the features and capabilities that meet user needs. This forms the foundation for designing and implementing the system's core functionalities.

\section{Functional Requirements}

Functional requirements define the specific behavior and functions of the system. For the dice game application, these include:

\begin{enumerate}
    \item {\bfseries Basic Functions}: The system must implement fundamental dice game mechanics, including:
    \begin{itemize}
        \item Ability to play classic dice games
        \item Rolling dice with randomized results
        \item Holding selected dice between rolls
        \item Banking scores based on game rules
        \item Displaying current turn results and game progress
    \end{itemize}
    \item {\bfseries AI Opponent}: The system should feature an AI opponent that dynamically adapts to player behavior and skill level.
    \item {\bfseries Game Variants}: The application should support a variety of dice games, providing diverse gameplay options.
    \item {\bfseries Player Analytics}: The system should track and analyze player statistics to inform AI decision-making.
    \item {\bfseries User Interface}: The application should provide an intuitive and consistent user interface for all game variants.
    \item {\bfseries Real-Time Feedback}: Users should receive performance feedback to understand and improve their gameplay strategies.
    \item {\bfseries Image Recognition}: The system should accurately detect and recognize physical dice through the device camera, detecting dice faces in real-time and accurately recognizing pip values.
\end{enumerate}


\section{Non-functional Requirements}
Non-functional requirements are essential for ensuring the quality and performance of the system. They help address issues such as latency, scalability, usability, reliability, and security. For the application, the following non-functional requirements are identified:
\begin{enumerate}
\item {\bfseries Performance}: The application should deliver a smooth user experience on mobile devices, with minimal latency in AI decision-making.
\item {\bfseries Scalability}: The system should be able to handle an increasing number of users and game variants.
\item {\bfseries Usability}: The user interface should be easy to navigate and accessible to diverse users.
\item {\bfseries Reliability}: The application should consistently provide accurate AI behavior and player analytics, maintaining user satisfaction.
\end{enumerate}

\section{Use Case Modelling}
Use cases describe how users interact with the system, illustrated using UML diagrams that visualize user interactions and the application's features.

\begin{figure}[h]
    \centering
    \includesvg[scale=0.9]{uml/render/main_menu_usecase.svg}
    \caption{Use case for the game's main menu.}
    \label{fig:main_menu_usecase}
\end{figure}

\begin{figure}[h]
    \centering
    \includesvg[scale=0.7]{uml/render/game_usecase.svg}
    \caption{Use case for the game's core gameplay.}
    \label{fig:game_usecase}
\end{figure}

\subsubsection{Main Menu Use Case}

Upon launching the application, users encounter the main menu, the central hub for interaction. This interface offers access to various game modes, settings, statistics, and instructional materials. The main menu serves as the gateway to core functionalities that shape the user experience.

Users can start a new game by selecting either the classic or custom game mode, allowing them to engage with predefined rules or define their own gameplay mechanics. Additionally, users can view detailed player statistics, offering insights into their performance, achievements, and progress over multiple sessions. Users can also view the settings menu which allows players to configure game parameters such as difficulty level, audio preferences, and visual themes. For guidance, the game rules and instructions provide an accessible reference for understanding game mechanics and strategies. Furthermore, the menu integrates virtual dice detection, enabling users to interact with real-world dice through image recognition. Table~\ref{tab:main_menu_usecase} summarizes the key interactions available in the main menu.

\begin{table}[ht!]
    \centering
    \begin{tabular}{|l|p{10cm}|}
        \hline
        \textbf{Actor} & \textbf{Description} \\
        \hline
        Player & Start Game: Initiates gameplay by selecting either classic or custom game modes. \\
        \hline
        Player & Show Settings: Provides access to customization options, including difficulty levels and interface preferences. \\
        \hline
        Player & Show Instructions: Displays an overview of game mechanics and rules for user reference. \\
        \hline
        Player & Show Statistics: Enables users to track their performance and game history. \\
        \hline
        Player & View Player Analysis: Offers in-depth statistics on past games, allowing players to analyze trends and optimize strategies. \\
        \hline
    \end{tabular}
    \caption{Main Menu Use Case Interactions}
    \label{tab:main_menu_usecase}
\end{table}

\subsubsection{Game Use Case}

The game system encapsulates core gameplay mechanics, providing an interactive experience where players can engage with dice-based games in both physical and digital formats. The gameplay revolves around rolling dice, making strategic decisions, and competing against AI opponents, which introduces an element of challenge and unpredictability.

\begin{table}[ht!]
    \centering
    \begin{tabular}{|l|p{10cm}|}
        \hline
        \textbf{Actor} & \textbf{Description} \\
        \hline
        Player & Play Classic Game: Engage in traditional dice games with predefined rules. \\
        \hline
        Player & Play Custom Game: Define custom rules and gameplay parameters. \\
        \hline
        Player & Roll Dice: Facilitates rolling dice either manually or through virtual detection. \\
        \hline
        Player & Hold Dice: Enables holding specific dice to optimize strategy. \\
        \hline
        Player & Bank Score: Secure points and prevent potential losses. \\
        \hline
        Player & Earn Achievements: Rewards for reaching milestones and completing challenges. \\
        \hline
        Player & Use Virtual Mode: Integrates augmented reality for real-world dice detection. \\
        \hline
        Player & Capture Dice Image: Enables dice roll capture via image recognition. \\
        \hline
        Player & Detect Dice Values: Processes dice images and updates game states accordingly. \\
        \hline
        AI & Make Strategic Decisions: Evaluates game conditions to make optimal moves. \\
        \hline
    \end{tabular}
    \caption{Game Use Case Interactions}
    \label{tab:game_usecase}
\end{table}

Players can roll dice using the virtual interface or capture dice rolls via image recognition, allowing seamless integration between physical and digital gaming experiences. During gameplay, players can choose to hold specific dice to optimize their strategy or bank points to secure their score. AI opponents actively participate by making decisions based on game state and probability calculations, creating a competitive and dynamic environment. Table~\ref{tab:game_usecase} presents the key interactions in the game system.

\section{Description of Tools and Technologies}

\subsection{Technologies and Tools}

\subsubsection{Kotlin}
\label{sec:kotlin}
Kotlin is a modern programming language that offers features like null safety, extension functions, and interoperability with Java, making it a preferred choice for Android development. Kotlin was chosen for this project to write the entire application code because of these advantages: its concise syntax reduces boilerplate and enhances readability, while its features like null safety improve application stability by reducing the risk of null pointer exceptions. Furthermore, its seamless integration with the Java ecosystem ensures that it can readily use Java libraries and existing Android code, and the language's ability to be compiled down to bytecode means increased cross-platform support. These advantages together result in enhanced productivity and maintainability~\cite{bib:kotlin}.

\subsubsection{Roboflow}
\label{sec:roboflow}
Roboflow is a computer vision platform that offers tools for dataset management, model training, and deployment \cite{bib:roboflow}. Roboflow was selected for this project because it significantly simplifies the process of building and deploying a custom dice detection model. The platform's efficient dataset preparation and augmentation capabilities helped improve the robustness of the model despite not having a large custom dataset \cite{bib:kavidataset}. Moreover, its tools for model training and optimization allowed for the efficient creation of a model suitable for mobile deployment. Importantly, Roboflow's managed API provides a seamless way to integrate the trained model into the Android application, enabling real-time inference capabilities that are crucial for the interactive dice-recognition component of the application, thereby enhancing the application's performance and reliability.

\subsubsection{Figma}
\label{sec:figma}
Figma is a collaborative interface design tool that was used to create the application's initial designs and prototypes~\cite{bib:figma}. Figma was used due to its collaborative nature allowing different stakeholders to collaborate during the design process and provide fast feedback. The tool provided a good level of functionality, and was used to create the user interface that could be implemented in the project, saving time during the development process, reducing effort.

\subsubsection{Git}
\label{sec:git}
Git is a distributed version control system that allows developers to track changes in their code-base through GitHub, collaborate with others, and manage project history efficiently. Git, hosted by GitHub, was chosen for source code management in this project because it enables collaborative development, allowing multiple developers to work on the project simultaneously without encountering conflicts. Additionally, Git's ability to track code versions is essential for maintaining the project's history, enabling developers to revert to previous states and maintain overall code integrity efficiently~\cite{bib:git}.

\subsubsection{Android Studio}
\label{sec:androidstudio}
Android Studio is the official integrated development environment for Android development, providing tools for building, testing, and debugging Android applications. Android Studio was used because it provides a comprehensive toolset that enables an efficient workflow. Its features, including a code editor, debugging tools, and emulator support, are essential for developing Android applications quickly and effectively. The deep integration with the Android platform helps in ensuring the application works well on the intended target platform~\cite{bib:androidstudio}.

\subsubsection{Jetpack Compose}
\label{sec:jetpackcompose}
Jetpack Compose is a modern toolkit for building native Android UI, offering a declarative approach that simplifies UI development and enhances code readability. It provides modular re-composition, allowing UI elements to update independently, which optimizes UI rendering efficiency. Although comparisons suggest that XML-based layouts may achieve better rendering speeds in certain scenarios, Jetpack Compose was chosen for its advantages in terms of flexibility, maintainability, and modern approach to Android UI development~\cite{bib:diva}. Jetpack compose also allows for fast and iterative development, which is beneficial for this project~\cite{bib:jetpackcompose}.

\subsection{Libraries}

\subsubsection{Dagger-Hilt}
\label{sec:daggerhilt}
Dagger-Hilt is a dependency injection library for Android that simplifies the setup and management of dependencies in Android applications. Dagger-Hilt was used in this project because it greatly reduces boilerplate code related to dependency injection, improving code modularity and making the project more testable. This is especially important for larger projects, allowing for more structured and organised code. It allows the application to easily scale, and can help with long-term maintainability~\cite{bib:daggerhilt}.

\subsubsection{Lottie Animation}
\label{sec:lottie}
Lottie is a library for rendering animations in real-time, allowing developers to use animations created in Adobe After Effects in their applications. Lottie was selected for its capabilities in rendering vector-based animations smoothly and efficiently, enhancing the application’s user interface. Lottie allowed animations to be created by UI/UX designers using their own tools and then be added into the application without requiring the implementation to be done by programmers. This allows for smoother animations and reduces the technical complexity and improves the user experience~\cite{bib:lottie}.

\subsubsection{Vico Charts}
\label{sec:vicocharts}
Vico Charts is a library for creating interactive and customizable charts in Android applications, providing a variety of chart types and features. Vico Charts was chosen because it offers a wide range of chart types and features that make it easy to represent data visually and dynamically. Vico Charts allows users to more easily interpret their data, and the library’s extensive customization options enable the data to be displayed attractively and consistently with the user interface~\cite{bib:vicocharts}.

\subsubsection{Timber}
\label{sec:timber}
Timber is a logging library for Android that provides a simple and flexible API for logging messages, making it easier to manage log output in Android applications. Timber was used for logging in this project to simplify and standardise the process of logging events and debugging information. Timber removes the clutter that comes from logging, and offers an elegant and easily readable interface and functionality for developers, thereby aiding in debugging and monitoring the application’s behavior~\cite{bib:timber}.

\subsubsection{JUnit 5}
\label{sec:junit}
JUnit 5 is composed of several modules, including JUnit Jupiter which is a combination of the programming and extension model for writing tests and extensions in JUnit 5~\cite{bib:junit}. JUnit 5 was chosen as the testing framework because of its modern architecture which allows for cleaner and more maintainable tests. It provides advanced testing functionalities and allows for an ease of development, allowing for the implementation of unit and integration tests with ease.

